%skeleton "lalr1.cc"
%require "3.8.1"
%header

%code requires {
	#include <string>
	#include <filesystem>
	#include "types.hpp"
	struct driver;
	extern FILE * yyin;
	struct def_pair {
		bool is_terminator = false;
		bool is_section = false;
		bool is_pool = false;
		bool is_import = false;
		unsigned value;
		std::string name;
		definition def;
	};
}

%code {
	#include "driver.hpp"
	#define CONSTOP(res, l, r, op) res.type = statement_type::op; res.identifier = l; res.value = r;;
	#define VAROP(res, l, r, op) res.type = statement_type::op; res.identifier = l; res.lhs = r;;
}

%define api.token.raw
%define api.token.constructor
%define api.value.type variant

%define parse.assert
%define parse.trace
%define parse.error detailed
%define parse.lac full

%param { driver& drv }
%locations

%define api.token.prefix {TOK_}
%token
	ASSIGN "=" PLUS "+=" MINUS "-=" STAR "*=" SLASH "/="
	AND "&&" OR "||" EQU "==" NOT "!="
	LPAREN "(" RPAREN ")" LBRACE "{" RBRACE "}"
	COLON ":" ELLIPSES "..." SEMICOLON ";" COMMA ","
;
%token
	ENV "env" ASM "asm"
	DEF "def" MAC "mac" USE "use" TERM "terminator" SECT "section" POOL "pool"
	CONST "const" TYPEDEF "typedef" TYPEBIG "typedef_big" DROP "drop" INCLUDE "include"
	IF "if" WHILE "while" DO "do" FOR "for" REPEAT "repeat" LOOP "loop"
	BREAK "break" CONTINUE "continue" RETURN "return" YIELD "yield" GOTO "goto" CALLASM "call"
;
%token <std::string> IDENTIFIER "identifier"
%token <int> NUMBER "number"
%token <int> ARGID "$n"
%token <std::string> STRING "string"

%type <param> parameter
%type <std::vector<param>> parameters
%type <arg> argument
%type <std::vector<arg>> arguments
%type <statement> statement
%type <std::vector<statement>> statements
%type <script> script
%type <def_pair> declaration
%type <std::vector<def_pair>> declarations

%%

file: blocks block {};
blocks: %empty {} | blocks block {};
block:
  include {}
| typedef {}
| environment {}
| assembly {}
| script {};

include: "include" "string" ";" {
	FILE * cur_file = yyin;
	driver new_driver;
	new_driver.merge(drv);
	new_driver.parse((std::filesystem::path(drv.file).parent_path() / $2).string());
	drv.merge(new_driver);
	yyin = cur_file;
};

typedef:
  "typedef" "identifier" "=" "number" ";" {
	if ($4 < 1 || $4 > 4) {
		err::fatal("Invalid size {} for type {}. Types must be from 1 to 4 bytes large", $2, $4);
	}
  drv.typedefs[$2].size = $4;
  }
| "typedef" "identifier" "=" "identifier" ";" {
  	drv.typedefs[$2].size = drv.get_type($4);
  }
| "typedef_big" "identifier" "=" "number" ";" {
	if ($4 < 1 || $4 > 4) {
		err::fatal("Invalid size {} for type {}. Types must be from 1 to 4 bytes large", $2, $4);
	}
	drv.typedefs[$2].size = $4;
	drv.typedefs[$2].big_endian = true;
}
| "typedef_big" "identifier" "=" "identifier" ";" {
	drv.typedefs[$2].size = drv.get_type($4);
	drv.typedefs[$2].big_endian = true;
};

environment: "env" "identifier" "{" declarations "}" {
	environment& env = drv.environments[$2];
	for (auto& i : $4) {
		if (i.is_terminator) {
			env.terminator = i.value;
		} else if (i.is_section) {
			env.section = i.name;
		} else if (i.is_pool) {
			env.pool = i.value;
		} else if (i.is_import) {
			drv.import(i.name, env);
		} else {
			i.def.bytecode = env.bytecode_count++;
			env.defines[i.name] = i.def;
		}
	}
};
declarations: %empty {} | declarations declaration {
	$1.push_back($2); $$ = $1;
};
declaration:
  "def" "identifier" "(" parameters ")" ";" {
	$$.name = $2;
	$$.def.type = deftype::DEF;
	$$.def.parameters = $4;
}
| "mac" "identifier" "(" parameters ")" "=" "identifier" ";" {
	$$.name = $2;
	$$.def.type = deftype::ALIAS;
	$$.def.alias = $7;
	$$.def.parameters = $4;
}
| "mac" "identifier" "(" parameters ")" "=" "identifier" "(" arguments ")" ";" {
	$$.name = $2;
	$$.def.type = deftype::MAC;
	$$.def.parameters = $4;
	$$.def.alias = $7;
	$$.def.arguments = $9;
}
| "use" "identifier" ";" { $$.is_import = true; $$.name = $2; }
| "terminator" "=" "number" ";" { $$.is_terminator = true; $$.value = $3; }
| "section" "=" "string" ";" { $$.is_section = true; $$.name = $3; }
| "pool" "=" "number" ";" { $$.is_pool = true; $$.value = $3; };

script:
  "identifier" "identifier" "{" statements "}" {
  	drv.scripts[$2].statements = $4;
  	drv.scripts[$2].env = $1;
};

statements: %empty {} | statements statement {
	$1.push_back($2); $$ = $1;
};
statement:
  "identifier" "(" arguments ")" ";" {
	$$.type = statement_type::CALL;
	$$.identifier = $1;
	$$.args = $3;
}
// constant operations
// TODO: Add z = x <> y operations.
| "identifier" "=" "number" ";"  { CONSTOP($$, $1, $3, ASSIGN); }
| "identifier" "+=" "number" ";" { CONSTOP($$, $1, $3, CONST_ADD); }
| "identifier" "-=" "number" ";" { CONSTOP($$, $1, $3, CONST_SUB); }
| "identifier" "*=" "number" ";" { CONSTOP($$, $1, $3, CONST_MULT); }
| "identifier" "/=" "number" ";" { CONSTOP($$, $1, $3, CONST_DIV); }
// variable operations
| "identifier" "=" "identifier" ";"  { VAROP($$, $1, $3, COPY); } // may load a global
| "identifier" "+=" "identifier" ";" { VAROP($$, $1, $3, ADD); }
| "identifier" "-=" "identifier" ";" { VAROP($$, $1, $3, SUB); }
| "identifier" "*=" "identifier" ";" { VAROP($$, $1, $3, MULT); }
| "identifier" "/=" "identifier" ";" { VAROP($$, $1, $3, DIV); }
| "identifier" "identifier" ";" {
	$$.type = statement_type::DECLARE;
	$$.size = drv.get_type($1);
	$$.identifier = $2;
}
// declare with constant value
| "identifier" "identifier" "=" "number" ";" {
	$$.type = statement_type::DECLARE_ASSIGN;
	$$.size = drv.get_type($1);
	$$.identifier = $2;
	$$.value = $4;
}
// declare with copy or global load
| "identifier" "identifier" "=" "identifier" ";" {
	$$.type = statement_type::DECLARE_COPY;
	$$.size = drv.get_type($1);
	$$.identifier = $2;
	$$.lhs = $4;
}
// label
| "identifier" ":" {
	$$.type = statement_type::LABEL;
	$$.identifier = $1;
}
| "drop" "identifier" ";" {
	$$.type = statement_type::DROP;
	$$.identifier = $2;
}
// Control structures
| "if" statement "{" statements "}" {
	$$.type = statement_type::IF;
	$$.conditions.push_back($2);
	$$.statements = $4;
}
| "while" statement "{" statements "}" {
	$$.type = statement_type::WHILE;
	$$.conditions.push_back($2);
	$$.statements = $4;
}
| "do" "{" statements "}" "while" statement ";" {
	$$.type = statement_type::DO;
	$$.conditions.push_back($6);
	$$.statements = $3;
}
| "for" statement ";" statement ";" statement ";" "{" statements "}" {
	$$.type = statement_type::FOR;
	$$.conditions.push_back($2);
	$$.conditions.push_back($4);
	$$.conditions.push_back($6);
	$$.statements = $9;
}
| "repeat" "number" "{" statements "}" {
	$$.type = statement_type::REPEAT;
	$$.value = $2;
	$$.statements = $4;
}
| "loop" "{" statements "}" {
	$$.type = statement_type::LOOP;
	$$.statements = $3;
}
| "break" ";" { $$.type = statement_type::BREAK; }
| "continue" ";" { $$.type = statement_type::CONTINUE; }
| "return" ";" { $$.type = statement_type::CALL; $$.identifier = "return"; }
| "yield" ";" { $$.type = statement_type::CALL; $$.identifier = "yield"; }
// These should insert code to automatically choose "far" versions.
| "goto" "identifier" ";" { $$.type = statement_type::GOTO; $$.identifier = $2; }
| "call" "identifier" ";" { $$.type = statement_type::CALLASM; $$.identifier = $2; }
;

parameters:
  %empty {}
| parameter { $$.push_back($1); }
| parameters "," parameter { $1.push_back($3); $$ = $1; };

parameter:
  "identifier" { $$.type = partype::ARG; $$.size = drv.get_type($1); }
| "const" "identifier" { $$.type = partype::CON; $$.size = drv.get_type($2); }
| "..." { $$.type = partype::VARARGS; };

arguments:
  %empty {}
| argument { $$.push_back($1); }
| arguments "," argument { $1.push_back($3); $$ = $1; };
argument:
  "identifier" { $$.str = $1; $$.type = argtype::VAR; }
| "number" { $$.value = $1; $$.type = argtype::NUM; }
| "string" { $$.str = $1; $$.type = argtype::STR; }
| "$n" { $$.value = $1; $$.type = argtype::ARG; };

assembly: "asm" "{" "}" {};

%%

void yy::parser::error(const location_type& l, const std::string& m) {
	std::cerr << l << ": ";
	err::error("{}\n", m);
}