#include <fmt/format.h>
#include <getopt.h>
#include <stdio.h>
#include "driver.hpp"
#include "exception.hpp"
#include "langs.hpp"

// This string is generated in the makefile using the current git version.
extern const char * version;
// Avoid printing the help text more than once.
static bool printed_help = false;

static void print_help(const char * program_name) {
	if (!printed_help) {
		printed_help = true;
		fmt::print(stderr, 
			"evscript v{}\n"
			"usage: {} -o <outfile> <infile>\n"
			"\t-h --help     Show this message.\n"
			"\t-l --language Set the output langage. \"help\" lists all languages.\n"
			"\t-o --output   Path to output file.\n"
			"\t-V --version  Show version number.\n",
			version, program_name
		);
	}
}

static const char shortopts[] = "hl:o:V";
static struct option const longopts[] = {
	{"help",      no_argument,       NULL, 'h'},
	{"language",  required_argument, NULL, 'l'},
	{"output",    required_argument, NULL, 'o'},
	{"version",   no_argument,       NULL, 'V'},
};

static FILE * fopen_output(const char * path) {
	FILE * outfile;
	if (path[0] == '-' && path[1] == 0) {
		outfile = stdout;
	} else {
		outfile = fopen(path, "w");
		if (!outfile) err::fatal("Failed to open {}: {}", path, strerror(errno));
	}
	return outfile;
}

int main(int argc, char ** argv) {
	// If stderr (fd 2) is a terminal, enable colored errors.
	err::color = isatty(2);

	// Options
	FILE * outfile = NULL;

	for (char c; (c = getopt_long_only(argc, argv, shortopts, longopts, NULL)) != -1;) {
		switch (c) {
		case 'h':
			print_help(argv[0]);
			exit(0);
			break;
		case 'l':
			if (std::string(optarg) == "help") {
				fmt::print(stderr, "Languages:\n");
				for (auto language_entry : language_lookup) {
					fmt::print(stderr, "{}\n", language_entry.first);
				}
				break;
			}
			if (language_lookup.contains(optarg)) {
				lang = *language_lookup[std::string(optarg)];
			} else {
				readlang(optarg);
			}
			break;
		case 'o':
			if (outfile) {
				err::warn("Multiple output files provided");
				fclose(outfile);
			}
			outfile = fopen_output(optarg);
			break;
		case 'V':
			fmt::print(stderr, "evscript v{}\n", version);
			exit(0);
			break;
		}
	}

	if (argc == optind) err::error("No input file");
	else if (argc != optind + 1) err::error("More than one input file given");
	if (!outfile) err::error("No output file");

	if (err::count > 0) {
		print_help(argv[0]);
		err::check();
	}

	// Parse input file.
	const char * input_path = argv[optind];
	driver drv;
	int result = drv.parse(input_path);
	if (result) return result;

	// Compile
	fmt::print(outfile, "; Generated by the evscript bytecode compiler, written by Eievui\n");
	// Produce constants for all bytecode.
	for (auto& [env_name, env] : drv.environments) for (auto& [name, define] : env.defines) {
		fmt::print(outfile, "DEF {}_{}_BYTECODE = {}\n", env_name, name, define.bytecode);
	}
	// output any assembly code provided by the user.
	for (auto& str : drv.assembly) {
		fmt::print(outfile, "{}", str);
	}
	// Then compile each script.
	for (auto& [name, script] : drv.scripts) {
		script.compile(outfile, name, drv.environments[script.env]);
	}
}
